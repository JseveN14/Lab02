Jessica Neves
CSC 201
2/26/2016
Lab 02

Simple Calculator

The goal of this lab was to create a program that acted like a calcultor. This lab asked us to explore slicing strings. We practiced methods with strings such as find, replace, and append. We were guided through breaking down a "hard coded" mathematic expression and "extracting" the numbers on either side of the operator. Once we accomplished that, we were instructed to explore how to handle invalid expressions. This would include mistypes such as missing values on either side of the operator and operators that were not recognized. We then had to put our program in a while loop and give the user an option to exit the program. The last section of the lab was to create a memory bank to recall previous expressions, as well as get the program to recognize parentheses.

Variables:
   - expr: String type; stores the user input expressions and commands.
   - memory_bank: List type with string elements. 
   - first_number: String type, "extracted" from expr; float, for calculation
   - second_number: String type, "extracted" from expr; float, for calculation
   - calculation: Integer type; Sum, difference, product, or quotient
   - answer: String type; using the insert method, each new answer is added to memory_bank

This lab was much more straightforward than the previous one. The basic algorithm for my program was to ask the user for an input (mathematic expression). I used the find method to locate the operator and store the indexes before as first_number and after as second_number. I stored the corresponding calculation, then stored the whole problem and answer as a string in a variable called answer. After each answer that is printed, I used the insert method to put the answer into the first index of an initially empty list called memory_bank.

In this program I created a series of if-elif-else statements within a while loop. The while loop around the outside of my nested if statements keeps the calculator running and asking for new expressions to input. I started my if-elif looking for instances of mistypes (accidental enter, accidental space). I then listed elif statements for inputs of expr to retrieve the memory bank. Then I used elif statements to search for invalid symbols and letters (both uppercase and lowercase). The next set of elif statements evaluate parentheses in my expression. First all the incorrect possibilities (parentheses within the expression, not closed, reversed) then the correct set. In the elif statement for the correct set I started by reevaluating expr to be the positions between the parentheses. 

Nested within the elif statement for correct parentheses, I set up another if-elif-else sequence to run the calculation. First it evaluated improper inputs: if parentheses were empty, and if the expression within the parentheses was incomplete(ended with an operator). If those were evalueted as false, the program would continue into the four elif statements to locate an operator inside the expression. Depending on which operator was found, the corresponding calculation would be conducted. Prior to calculation, I extracted the numbers on either side of the operator. I used two more if-else statements within the elif statement to verify that each of the numbers was a valid input. Both if statements pertained to decimal placement. If an input ended with a decimal or was only a period, it would give a "invalid expression" print statement. The if statement for the second number also looks for additional operators, as more than one operator in an expression would originally crash the program. This happens because "first_number" is any value from index [0] up to the first instance of an operator. Any operators after that were being stored in "second_number". I then converted them to floats to preserve accuracy. I stored the calculation in a variable, then concatenated it with the expression and stored that in a variable called "answer" which is printed in the console. After the print statement executes, the answer is inserted into the memory bank at index [0] and "memory_bank" is updated. The elif statement ends, and the while loop continues.

Further down the program, if the expression has no parentheses, an elif statement fisrt evaluates incomplete expressions (expressions ending with an operator). From there, the program evaluates the elif statements for each of the four operators with if-else statements nested inside to evaluate each of the extracted numbers. If no operator is found, the program jumps to an else statement at the end to produce an "invalid expression" print statement.

I was able to accomplish the initial extraction, and creating the memory bank without much difficulty. I found the memory bank to be the easiest part of this assignment. While the handout listed that we might need to use the replace method, I found the insert method also worked well for this program. I created an empty list, and added each "answer" to it in the [0] index. I could tell the memory bank to only display the first 3 elements, so each time a new element was added, the list would automatically shift. I established if-else statements in case the memory bank was empty. Initially, if the user typed "last 1" the program would crash because the memory bank was empty and there was nothing stored in the [0] index. I discovered that placement of the memory bank elif statements was important. I accidentally placed them after the elif blocks for invalid letters and this caused the inputs to give an "invalid expression" print statement.

I would imagine that in order to evaluate expressions with multiple grouping symbols, it could be possible to evaluate each grouped expression first, storing each of those values, and then applying the operator in the middle. This would also require that the elif statements for each operator is in the order of mathematical priority (PEMDAS).

The biggest challenge for me was getting the program to recognize parentheses, and handling mistypes such as incorrect operators or non-integers. In getting my program to recognize parentheses I first experimented with a while loop with a number of 'or' conditions. This process proved unsuccessful. I then realized it was more appropriate to evaluate my expression for parentheses first in an elif. If the correct set was found, I could then nest the if-elif-else statements for the operators inside that. I covered most of the improper parenthetical inputs and combinations.

A critique I was given on the number extraction, was to save expr.find() as a variable. This proved to be difficult. I experimented with it in another file, but I could not get it to agree with this code. 

The else statement at the very end of my program will print an invalid expression for any expression not containing an operator. Before the expression is evaluated for operators and calculation, I wrote in an elif to look for operators in the last index of the expression and print an invalid expression if it finds any. This would cover a missing second number. 

I attempted to cover as many instances of invalid symbols as possible. I set them all up in one elif-or statement. The same method is viable for letters as well. It is a time consuming process, and does not look neat. However, this method seems to solve the frustrating issue of my program crashing if the user inputs letters instead of numbers(an issue I had with the previous assignment). Before I created the elif statements for the invalid symbols and letters, I found that due to the conditions I used for the operators, if the operator was entered with invalid inputs on either side it would crash. 

One of the more strange inputs that could crash the program was: ( + ). Parentheses around the outside and a space on either side of the +. I decided to include " " as an invalid symbol. Being careful to list the commands for the memory bank before the invalid symbols avoids the program producing an "invalid expression" print statement. 

Overall, this was a much more successful program than the previous assignment. I look forward to revisiting this project with more tools and knowledge available.