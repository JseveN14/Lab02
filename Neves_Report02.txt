Jessica Neves
CSC 201
2/26/2016
Lab 02

Simple Calculator

The goal of this lab was to create a program that acted like a calcultor. This lab asked us to explore slicing strings. We practiced methods with strings such as find, replace, and append. We were guided through breaking down a "hard coded" mathematic expression and "extracting" the numbers on either side of the operator. Once we accomplished that, we were instructed to explore how to handle invalid expressions. This would include mistypes such as missing values on either side of the operator and operators that were not recognized. We then had to put our program in a while loop and give the user an option to exit the program. The last section of the lab was to create a memory bank to recall previous expressions, as well as get the program to recognize parentheses.

Variables:
   - expr: String type; stores the user input expressions and commands.
   - memory_bank: List type with string elements. 
   - first_number: Integer type, "extracted" from expr; float, for calculation
   - second_number: Integer type, "extracted" from expr; float, for calculation
   - calculation: Integer type; Sum, difference, product, or quotient
   - answer: String type; using the insert method, each new answer is added to memory_bank

This lab was much more straightforward than the previous one. The basic algorithm for my program was to ask the user for an input (mathematic expression). I used the find method to locate the operator and store the indexes before as first_number and after as second_number. I stored the corresponding calculation, then stored the whole problem and answer as a string in a variable called answer. After each answer that is printed, I used the insert method to put the answer into the first index of an initially empty list called memory_bank.

In this program I created a series of if-elif-else statements within a while loop. The while loop around the outside of my nested if statements keeps the calculator running and asking for new expressions to input. I started my if-elif looking for instances of mistypes (accidental enter, accidental space). I listed elif statements for inputs of expr to retrieve the memory bank. Then I used elif statements to evaluate parentheses in my expression. First all the incorrect possibilities (parentheses within the expression, not closed, reversed) then the correct set. 

In the elif statement for the correct set I had to reevaluate expr to be the positions between the parentheses. Nested within my elif statement, I set up another if-elif sequence to run the calculation. First it evaluated improper inputs (if parentheses were empty, and if the expression within the parentheses was incomplete). If those were evalueted as false, the program would continue into the four elif statements to locate an operator inside the expression. Depending on which operator was found, the corresponding calculation would be conducted. Prior to calculation, I extracted the numbers on either side of the operator. I then converted them to floats to preserve accuracy. I stored the calculation in a variable, then concatenated it with the expression and stored that in a variable called answer which is printed in the console. After the print statement executes, the answer is inserted into the memory bank. The elif statement ends, and the while loop continues.

Further down the program, if the expression has no parentheses, an elif statement fisrt evaluates incomplete expressions, or expressions ending with an operator. From there, the program evaluates the elif statements for each of the four operators. If no operator is found, the program jumps to an else statement at the end to produce an "invalid expression" print statement.

I was able to accomplish the initial extraction, and creating the memory bank without much difficulty. I found the memory bank to be the easiest part of this assignment. While the handout listed that we might need to use the replace method, I found the insert method also worked well for this program. I created an empty list, and added each answer to it in the [0] index. I could tell the memory bank to only display the first 3 elements, so each time a new element was added, the list would automatically shift.

I would imagine that in order to evaluate expressions with multiple grouping symbols, it could be possible to evaluate each grouped expression first, storing each of those values, and then applying the operator in the middle. This would also require that the code for each operator is in the order of mathematical priority (PEMDAS), as I wrote them as elif conditions.

The biggest challenge for me was getting the program to recognize parentheses, and handling mistypes such as incorrect operators or non-integers. In getting my program to recognize parentheses I first experimented with a while loop with a number of 'or' conditions. This process proved unsuccessful. I then realized it was more appropriate to evaluate my expression for parentheses first in an elif. If the correct set was found, I could then nest the if-elif-else statements for the operators inside that. I covered most of the improper parenthetical inputs and combinations.

A critique I was given on the number extraction, was to save expr.find() as a variable. This proved to be difficult. I experimented with it in another file, but I could not get it to agree with this code. 

The else statement at the very end of my program will print an invalid expression for any expression not containing an operator or . Before the expression is evaluated for operators and calculation, I wrote in an elif to look for operators in the last index of the expression and print an invalid expression if it finds any. This would cover a missing second number. 

I attempted to cover as many instances of invalid symbols as possible. I set them all up in one elif-or statement. The same method is viable for letters as well. It is a time consuming process, and does not look neat. However, this method seems to solve the frustrating issue of my program crashing if the user inputs letters instead of numbers(an issue I had with the previous assignment). Before I created the elif statements for the invalid symbols and letters, I found that due to the conditions I used for the operators, if the operator was entered with invalid inputs on either side it would crash. 

One of the more strange inputs that could crash the program was: ( + ). Parentheses around the outside and a space on either side of the +. I decided to include " " as an invalid symbol. I adjusted the commands for the memory bank to not have spaces, as that would print an invalid expression. One particular input that could definitely crash the program is a complete expression with more than two numbers since the code only looks for two (one before the operator and one after it). An expression such as 5+5+5 would crash the program.

Overall, this was a much more successful program than the previous assignment.